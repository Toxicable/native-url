{"version":3,"file":"index.umd.js","sources":["../src/format.js","../third_party/format.js","../src/constants.js","../src/parse.js","../src/resolve.js"],"sourcesContent":["/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport qs from 'querystring';\nimport parse from './parse';\nimport format from '../third_party/format';\n\nconst slashedProtocols = /https?|ftp|gopher|file/;\n\nexport default function(urlObj) {\n  if (typeof urlObj === 'string') {\n    urlObj = parse(urlObj);\n  }\n\n  const { protocol, host, pathname, search, hash } = format(\n    urlObj,\n    qs,\n    slashedProtocols\n  );\n\n  return `${protocol}${host}${pathname}${search}${hash}`;\n}\n","// Format function modified from nodejs\n// Copyright Joyent, Inc. and other Node contributors.\n//\n// Permission is hereby granted, free of charge, to any person obtaining a\n// copy of this software and associated documentation files (the\n// \"Software\"), to deal in the Software without restriction, including\n// without limitation the rights to use, copy, modify, merge, publish,\n// distribute, sublicense, and/or sell copies of the Software, and to permit\n// persons to whom the Software is furnished to do so, subject to the\n// following conditions:\n//\n// The above copyright notice and this permission notice shall be included\n// in all copies or substantial portions of the Software.\n//\n// THE SOFTWARE IS PROVIDED \"AS IS\", WITHOUT WARRANTY OF ANY KIND, EXPRESS\n// OR IMPLIED, INCLUDING BUT NOT LIMITED TO THE WARRANTIES OF\n// MERCHANTABILITY, FITNESS FOR A PARTICULAR PURPOSE AND NONINFRINGEMENT. IN\n// NO EVENT SHALL THE AUTHORS OR COPYRIGHT HOLDERS BE LIABLE FOR ANY CLAIM,\n// DAMAGES OR OTHER LIABILITY, WHETHER IN AN ACTION OF CONTRACT, TORT OR\n// OTHERWISE, ARISING FROM, OUT OF OR IN CONNECTION WITH THE SOFTWARE OR THE\n// USE OR OTHER DEALINGS IN THE SOFTWARE.\n\nexport default function(urlObj, qs, slashedProtocols) {\n  let { auth, hostname } = urlObj;\n  let protocol = urlObj.protocol || '';\n  let pathname = urlObj.pathname || '';\n  let hash = urlObj.hash || '';\n  let query = urlObj.query || '';\n  let host = false;\n\n  auth = auth ? encodeURIComponent(auth).replace(/%3A/i, ':') + '@' : '';\n\n  if (urlObj.host) {\n    host = auth + urlObj.host;\n  } else if (hostname) {\n    host = auth + (~hostname.indexOf(':') ? `[${hostname}]` : hostname);\n    if (urlObj.port) {\n      host += ':' + urlObj.port;\n    }\n  }\n\n  if (query && typeof query === 'object') {\n    // query = '' + new URLSearchParams(query);\n    query = qs.encode(query);\n  }\n\n  let search = urlObj.search || (query && `?${query}`) || '';\n\n  if (protocol && protocol.substr(-1) !== ':') protocol += ':';\n\n  if (\n    urlObj.slashes ||\n    ((!protocol || slashedProtocols.test(protocol)) && host !== false)\n  ) {\n    host = '//' + (host || '');\n    if (pathname && pathname[0] !== '/') pathname = '/' + pathname;\n  } else if (!host) {\n    host = '';\n  }\n\n  if (hash && hash[0] !== '#') hash = '#' + hash;\n  if (search && search[0] !== '?') search = '?' + search;\n\n  pathname = pathname.replace(/[?#]/g, encodeURIComponent);\n  search = search.replace('#', '%23');\n\n  return {\n    protocol,\n    host,\n    pathname,\n    search,\n    hash\n  };\n}\n","/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nexport const PROTOCOL = 'xyz://';\nexport const PARSE_PROTOCOL = 'http://';\nexport const HOST = 'w.w';\nexport const BASE_URL = PROTOCOL + HOST;\nexport const PARSE_BASE_URL = PARSE_PROTOCOL + HOST;\n","/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport qs from 'querystring';\nimport format from './format';\nimport { PARSE_BASE_URL, HOST } from './constants';\n\nconst slashedProtocols = /^https?|ftp|gopher|file/;\nconst urlRegex = /^(.+?)([#?].*)/;\nconst protocolRegex = /^([a-z0-9.+-]*:)(\\/{0,3})(.*)/i;\nconst slashesRegex = /^([a-z0-9.+-]*:)?\\/\\/\\/*/i;\nconst ipv6Regex = /^([a-z0-9.+-]*:)(\\/{0,2})\\[(.*)\\]$/i;\n\nfunction safeDecode(url) {\n  try {\n    return decodeURI(url);\n  } catch (_) {\n    return url;\n  }\n}\n\nexport default function(urlStr, parseQs = false, slashesDenoteHost = false) {\n  urlStr = safeDecode(urlStr.trim());\n\n  const slashesMatch = urlStr.match(urlRegex);\n  if (slashesMatch) {\n    urlStr = slashesMatch[1].replace(/\\\\/g, '/') + slashesMatch[2];\n  } else {\n    urlStr = urlStr.replace(/\\\\/g, '/');\n  }\n\n  // IPv6 check\n  if (ipv6Regex.test(urlStr)) {\n    // Add trailing slash to IPV6 urls to match parsing\n    if (urlStr.slice(-1) !== '/') urlStr += '/';\n  }\n\n  const protocolMatch =\n    !/(^javascript)/.test(urlStr) && urlStr.match(protocolRegex);\n  let slashes = slashesRegex.test(urlStr);\n  let protocolPrefix = '';\n\n  if (protocolMatch) {\n    if (!slashedProtocols.test(protocolMatch[1])) {\n      // Replace invalid protocol with a valid one for correct parsing\n      protocolPrefix = protocolMatch[1].toLowerCase();\n      urlStr = `${protocolMatch[2]}${protocolMatch[3]}`;\n    }\n\n    if (!protocolMatch[2]) {\n      slashes = false;\n      if (slashedProtocols.test(protocolMatch[1])) {\n        protocolPrefix = protocolMatch[1];\n        urlStr = `${protocolMatch[3]}`;\n      } else {\n        urlStr = `//${protocolMatch[3]}`;\n      }\n    }\n\n    // Handle '///' in url Eg: http:///s//a/b/c\n    // TODO: file:/some/dir/# should become file:///some/dir/# according to the url module in node\n    if (protocolMatch[2].length === 3 || protocolMatch[2].length === 1) {\n      protocolPrefix = protocolMatch[1];\n      urlStr = `/${protocolMatch[3]}`;\n    }\n  }\n\n  // If port is 80 we change it to 8000 and undo it later\n  let portMatch = urlStr.match(/(:[0-9]+)/);\n  let portSuffix = '';\n\n  if (portMatch && portMatch[1] && portMatch[1].length === 3) {\n    portSuffix = portMatch[1];\n    urlStr = urlStr.replace(portSuffix, `${portSuffix}00`);\n  }\n\n  let url;\n  let res = {};\n  let err = '';\n  let preSlash = '';\n\n  try {\n    url = new URL(urlStr);\n  } catch (e) {\n    err = e;\n\n    // Handle url with slashes - Eg: //some_url\n    if (\n      !protocolPrefix &&\n      !slashesDenoteHost &&\n      /^\\/\\//.test(urlStr) &&\n      !/^\\/\\/.+[@.]/.test(urlStr)\n    ) {\n      preSlash = '/';\n      urlStr = urlStr.substr(1);\n    }\n\n    try {\n      url = new URL(urlStr, PARSE_BASE_URL);\n    } catch (_) {\n      // Unable to parse the url\n      // If the URL has only the protocol - Eg: \"foo:\"\n      res.protocol = protocolPrefix;\n      res.href = protocolPrefix;\n      return res;\n    }\n  }\n\n  res.slashes = slashes && !preSlash;\n  res.host = url.host.includes(HOST) ? '' : url.host;\n  res.hostname = url.hostname.includes(HOST)\n    ? ''\n    : url.hostname.replace(/(\\[|\\])/g, '');\n  res.protocol = err ? protocolPrefix || null : url.protocol;\n\n  res.search = url.search.replace(/\\\\/g, '%5C');\n  res.hash = url.hash.replace(/\\\\/g, '%5C');\n\n  const hashSplit = urlStr.split('#');\n  // Handle case when there is a lone '?' in url\n  // Eg: http://example.com/?\n  if (!res.search && hashSplit[0].includes('?')) {\n    res.search = '?';\n  }\n  // Similarly handle lone '#' Eg: http://example.com/#\n  if (!res.hash && hashSplit[1] === '') {\n    res.hash = '#';\n  }\n\n  // URLSearchParams is not supported in Edge 16\n  // res.query = res.searchParams;\n  res.query = parseQs ? qs.decode(url.search.substr(1)) : res.search.substr(1);\n\n  res.pathname = preSlash + safeDecode(url.pathname).replace(/\"/g, '%22');\n\n  // Chrome parses \"#abc\" as \"about:blank#abc\"\n  if (res.protocol === 'about:' && res.pathname === 'blank') {\n    res.protocol = '';\n    res.pathname = '';\n  }\n\n  // Partial url that does not start with a /\n  // example www.example.com\n  if (err && urlStr[0] !== '/') res.pathname = res.pathname.substr(1);\n\n  // Remove additional trailing slashes added by URL\n  if (\n    protocolPrefix &&\n    !slashedProtocols.test(protocolPrefix) &&\n    urlStr.slice(-1) !== '/' &&\n    res.pathname === '/'\n  ) {\n    res.pathname = '';\n  }\n\n  res.path = res.pathname + res.search;\n\n  res.auth = [url.username, url.password]\n    .map(decodeURIComponent)\n    .filter(Boolean)\n    .join(':');\n  res.port = url.port;\n\n  // Undo port to its original value, 8000 -> 80\n  if (portSuffix) {\n    res.host = res.host.replace(`${portSuffix}00`, portSuffix);\n    res.port = res.port.slice(0, -2);\n  }\n\n  res.href = preSlash ? `${res.pathname}${res.search}${res.hash}` : format(res);\n\n  const excludedKeys = /^(file)/.test(res.href) ? ['host', 'hostname'] : [];\n  Object.keys(res).forEach(k => {\n    if (!excludedKeys.includes(k)) res[k] = res[k] || null;\n  });\n\n  return res;\n}\n","/*\n * Copyright 2019 Google LLC\n *\n * Licensed under the Apache License, Version 2.0 (the 'License');\n * you may not use this file except in compliance with the License.\n * You may obtain a copy of the License at\n *\n *     https://www.apache.org/licenses/LICENSE-2.0\n *\n * Unless required by applicable law or agreed to in writing, software\n * distributed under the License is distributed on an 'AS IS' BASIS,\n * WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.\n * See the License for the specific language governing permissions and\n * limitations under the License.\n */\n\nimport parse from './parse';\nimport format from './format';\nimport { BASE_URL, PROTOCOL, HOST } from './constants';\n\nconst resolveProtocolRegex = /^([a-z0-9.+-]*:\\/\\/\\/)([a-z0-9.+-]:\\/*)?/i;\nconst slashedProtocols = /https?|ftp|gopher|file/;\n\nexport function resolve(fromUrl, toUrl) {\n  let parsedFrom = typeof fromUrl === 'string' ? parse(fromUrl) : fromUrl;\n  fromUrl = typeof fromUrl === 'object' ? format(fromUrl) : fromUrl;\n  let parsedTo = parse(toUrl);\n  let prefix = '';\n\n  // Handle incomplete urls without slashes Eg: foo:a/b\n  if (parsedFrom.protocol && !parsedFrom.slashes) {\n    prefix = parsedFrom.protocol;\n\n    fromUrl = fromUrl.replace(parsedFrom.protocol, '');\n    prefix += toUrl[0] === '/' || fromUrl[0] === '/' ? '/' : '';\n  }\n\n  if (prefix && parsedTo.protocol) {\n    prefix = '';\n    if (!parsedTo.slashes) {\n      prefix = parsedTo.protocol;\n      toUrl = toUrl.replace(parsedTo.protocol, '');\n    }\n  }\n\n  // Handle http:///xyz urls\n  const protocolMatch = fromUrl.match(resolveProtocolRegex);\n  if (protocolMatch && !parsedTo.protocol) {\n    // protocolMatch[2] handles - file:///C:/DEV/Haskell/lib/HXmlToolbox-3.01/examples/\n    prefix = protocolMatch[1] + (protocolMatch[2] || '');\n    fromUrl = fromUrl.substr(prefix.length);\n\n    // :/// -> :// If toUrl is of the form //xyz\n    if (/^\\/\\/[^/]/.test(toUrl)) prefix = prefix.slice(0, -1);\n  }\n\n  const normalizedFromUrl = new URL(fromUrl, BASE_URL + '/');\n  let resolved = new URL(toUrl, normalizedFromUrl)\n    .toString()\n    .replace(PROTOCOL, '')\n    .replace(HOST, '');\n\n  // Remove unwanted trailing slash\n  if (\n    !slashedProtocols.test(resolved) &&\n    !toUrl.includes('.') &&\n    fromUrl.slice(-1) !== '/' &&\n    toUrl.slice(-1) !== '/' &&\n    resolved.slice(-1) === '/'\n  ) {\n    resolved = resolved.slice(0, -1);\n  }\n\n  // If prefix remove the leading slash\n  if (prefix) {\n    resolved = prefix + (resolved[0] === '/' ? resolved.substr(1) : resolved);\n  }\n\n  return resolved;\n}\n\nexport function resolveObject(fromUrl, toUrl) {\n  return parse(resolve(fromUrl, toUrl));\n}\n"],"names":["const","slashedProtocols","urlObj","parse","qs","protocol","pathname","hash","query","host","auth","encodeURIComponent","replace","hostname","indexOf","port","encode","search","substr","slashes","test","format","PROTOCOL","HOST","BASE_URL","PARSE_BASE_URL","urlRegex","protocolRegex","slashesRegex","ipv6Regex","safeDecode","url","decodeURI","_","urlStr","parseQs","slashesDenoteHost","slashesMatch","trim","match","slice","protocolMatch","protocolPrefix","toLowerCase","length","portMatch","portSuffix","res","err","preSlash","URL","e","href","includes","hashSplit","split","decode","path","username","password","map","decodeURIComponent","filter","Boolean","join","excludedKeys","Object","keys","forEach","k","resolveProtocolRegex","resolve","fromUrl","toUrl","parsedFrom","parsedTo","prefix","normalizedFromUrl","resolved","toString"],"mappings":"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"}